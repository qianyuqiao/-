### 参数传递过程到底发生了什么
```
值传递：
1.基本类型
直接复制
2.类对象
调用拷贝构造函数生成一个副本，将此副本作为实参传递进去
```
引用传递：
```
直接传递的是指针
```

### 当类中有指针时，可以直接用默认的拷贝构造函数吗（什么时候必须自己定义拷贝构造函数？）
```
不能，需要新建对象并让新的指针指向这个新的对象
当使用值传递时，会调用拷贝构造函数，如果类中成员有
```

### 以下哪个函数时拷贝构造函数？为什么？
```
X::X(const X&);   //拷贝构造函数
X::X(X&, int a=1);   //拷贝构造函数
X::X(X&, int a=1, int b=2);  //拷贝构造函数
X::X(const volatile X&);
X::X(volatile X&);
都是
```
注意,如果一个类中只存在一个参数为 X& 的拷贝构造函数,那么就不能使用const X或volatile X的对象实行拷贝初始化

### 构造函数可以重载吗?析构函数可以重载吗
```
构造函数可以重载
析构函数由于没有参数，不能重载
```
### MSL是多少?为什么是2MSL?
```
MSL和系统有关:
windows:2min
linux:60s
unix:30s

假设A是主动断开方，B是被动断开方，A在收到B发来的FIN后会发出ACK,
然后在TIME_WAIT状态等待2MSL,这是因为如果ACK报文在传输的过程中丢失的话，A会认为会在
2MSL内收到来自B的重传报文。经过2MSL还没收到报文的话，A会认为B已经收到报文。
```

### TTL是什么？
time to live,指一个ip报文被路由器丢弃前所能经过的最大网段数，一般每经过一个路由器这个值会减1

