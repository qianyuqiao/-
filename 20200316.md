### 端口号为什么是16位？
因为最大可用的端口号是65535

### ip地址为什么是32位？
8位为一段，每段最大是255

### C++返回引用？？
https://blog.csdn.net/weixin_40539125/article/details/81410008

### C++转型？？
static cast:类型转换，基类子类转换，添加const属性
```
double a = 10.23;
int b = static_cast<int>(a);
Base* ptr = new Child();
Child* p2 = static_cast<Child*>(ptr);  // 向下转型...这并不一定安全
const Base *ptr3 = static_cast<const Base*>(ptr)
```
dynamic_cast:
只能用于指针或引用，只能用于有虚函数的类<br>
失败的话返回一个0;
```
Base* ptr = new Base();
Child *ptr = dynamic_cast<Child*>(ptr);
if (!ptr) cout << "0" << endl;
```
const_cast
```
用来将常量性去除
```

reinterpret_cast：
```
可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针，
或者把一种指针转换成另一种指针。
```

### 如何理解dynamic_cast?
https://blog.csdn.net/xingkongfenqi/article/details/49148885
```
将基类类型的指针或引用安全地转换为其派生类类型的指针或引用<br>
dynamic_cast用于具有继承关系的子类和基类之间的类型转换
通过dynamic_cast可以不调用重写后的函数
如
class Tfather
{
public:
	virtual void base() {};
	void f() { cout << "father's f()" << endl; }
};

// 我是子类
class Tson : public Tfather
{
public:
	void f() { cout << "son's f()" << endl; }
};

int main()
{
	Tson* a = new Tson;
	Tfather* tf = dynamic_cast<Tfather*>(a);
	tf->f();
	return 0;
}
结果：打印father's f()
```
父类指针指向子类对象，然后转换为子类
```
int main()
{
	Tfather* a = new Tson;
	Tson* ts = dynamic_cast<Tson*>(a);
	if (ts) ts->f();
	else cout << "failed" << endl;
	return 0;
}
```
结果:
```
son()'s f()
```
强制转换
```
int main()
{
	Tfather* a = new Tfather;
	Tson* ts = dynamic_cast<Tson*>(a);
	if (ts) ts->f();
	else cout << "failed" << endl;
	return 0;
}
```
失败，为什么呢？这是因为父类对象内存里没有子类的信息。。。<br>
但是如果是父类指针指向子类对象，其实子类对象内存里是有父类信息的。。

### 什么时候可以用static_cast替代dynamic_cast呢？
基类指针指向子类对象的时候
```
比如
Father* a = new Son;
这时候用
Tfather* a = new Tson;
Tson* ts = static_cast<Tson*>(a);
是可以的。
```
子类指针转换为父类指针的时候
```
Tson* a = new Tson;
Tfather* ts = static_cast<Tfather*>(a);
```

### 什么时候必须用dynamic_cast,不能用static_cast?
1.父类指针的转换，用static_cast，否则对成员变量的访问是不安全的
```
class Tson : public Tfather
{
public:
	void f() { cout << "son's f()" << endl; }
	int a = 0;
};

int main()
{
	Tfather* a = new Tfather;
	Tson* ts = static_cast<Tson*>(a);
	cout << ts->a << endl;
	return 0;
}
```
猜猜结果是什么？
```
-33686019
```
显然是一个对象内存以外的数。。<br
2.交叉转换
```
classA
{
public:
intm_iNum;
virtual void f(){}
};
class B:public A
{};
class D:public A
{};
void foo()
{
B*pb=new B;
pb->m_iNum=100;
//D*pd1=static_cast<D*>(pb);//compile error
D*pd2=dynamic_cast<D*>(pb);//pd2isNULL
delete pb;
}
```

### RTTI？
```
https://www.cnblogs.com/tgycoder/p/5427303.html
```

### 从汇编角度下考虑函数调用？
https://www.jianshu.com/p/dccc52855a8b
https://www.cnblogs.com/zhyryxz/archive/2010/10/12/1848938.html
```
	int a = 1;
009E6418  mov         dword ptr [a],1  
	a = add(a);
009E641F  mov         eax,dword ptr [a]  
009E6422  push        eax  
009E6423  call        add (09E15AAh)  
009E6428  add         esp,4  
009E642B  mov         dword ptr [a],eax  
```

### 值传递，指针传递，引用传递的区别？
